ğŸ“… SwiftUI Testing â€“ 5-Day Series

SwiftUI Snapshot Testing âœ…

SwiftUI ViewModel Testing (Advanced) â¬…ï¸ Today

SwiftUI Async & Concurrency Testing

SwiftUI Navigation & Coordinator Testing

SwiftUI CI Testing Strategy

ğŸ§ª SwiftUI ViewModel Testing (Day 2)

In SwiftUI, ViewModels are the most important test surface.
If ViewModels are correct, the UI almost always is.

âœ… Test logic
âŒ Donâ€™t test SwiftUI internals

ğŸ§  What to Test in a ViewModel

You should test:

State transitions

Business rules

Error handling

Edge cases

Async behavior

You should NOT test:

@State / @Published mechanics

View rendering

body recomputation

1ï¸âƒ£ ViewModel With Explicit UI State (Baseline)
View State
enum LoginState {
    case idle
    case loading
    case success(User)
    case error(String)
}

ViewModel
@MainActor
final class LoginViewModel: ObservableObject {

    @Published private(set) var state: LoginState = .idle

    private let service: LoginServicing

    init(service: LoginServicing) {
        self.service = service
    }

    func login(username: String, password: String) async {
        state = .loading

        do {
            let user = try await service.login(
                username: username,
                password: password
            )
            state = .success(user)
        } catch {
            state = .error("Login failed")
        }
    }
}

2ï¸âƒ£ Mocking Dependencies (Critical)
Protocol
protocol LoginServicing {
    func login(username: String, password: String) async throws -> User
}

Mock Success Service
struct MockLoginSuccessService: LoginServicing {
    func login(username: String, password: String) async throws -> User {
        User(name: "Test User")
    }
}

Mock Failure Service
struct MockLoginFailureService: LoginServicing {
    func login(username: String, password: String) async throws -> User {
        throw URLError(.badServerResponse)
    }
}

3ï¸âƒ£ Testing Success State
func testLoginSuccess() async {
    let vm = LoginViewModel(
        service: MockLoginSuccessService()
    )

    await vm.login(username: "test", password: "123")

    if case .success(let user) = vm.state {
        XCTAssertEqual(user.name, "Test User")
    } else {
        XCTFail("Expected success state")
    }
}

4ï¸âƒ£ Testing Error State
func testLoginFailure() async {
    let vm = LoginViewModel(
        service: MockLoginFailureService()
    )

    await vm.login(username: "test", password: "123")

    if case .error(let message) = vm.state {
        XCTAssertEqual(message, "Login failed")
    } else {
        XCTFail("Expected error state")
    }
}

5ï¸âƒ£ Testing State Transitions (Important)
func testLoginStateSequence() async {
    let vm = LoginViewModel(
        service: MockLoginSuccessService()
    )

    XCTAssertEqual(vm.state, .idle)

    let task = Task {
        await vm.login(username: "test", password: "123")
    }

    // Allow async state update
    await Task.yield()

    XCTAssertEqual(vm.state, .loading)

    await task.value
}


Why this matters:

Confirms loading â†’ success

Prevents UI flicker bugs

6ï¸âƒ£ Testing Multiple Calls / Edge Cases
func testMultipleLoginCalls() async {
    let vm = LoginViewModel(
        service: MockLoginSuccessService()
    )

    await vm.login(username: "a", password: "1")
    await vm.login(username: "b", password: "2")

    if case .success(let user) = vm.state {
        XCTAssertEqual(user.name, "Test User")
    } else {
        XCTFail("Expected success state")
    }
}

7ï¸âƒ£ Testing That ViewModel Is @MainActor Safe
func testRunsOnMainActor() async {
    let vm = LoginViewModel(
        service: MockLoginSuccessService()
    )

    await vm.login(username: "test", password: "123")

    XCTAssertTrue(Thread.isMainThread)
}


Prevents:

UI update crashes

Race conditions

8ï¸âƒ£ What NOT to Do in ViewModel Tests

ğŸš« Sleeping threads
ğŸš« Waiting on expectations unnecessarily
ğŸš« Testing delays instead of outcomes
ğŸš« Using real network calls

ğŸ”¥ Common ViewModel Testing Mistakes

âŒ Testing too much UI behavior
âŒ Boolean-heavy states
âŒ Not testing failure paths
âŒ No protocol-based mocking

ğŸ§  Interview Power Answer

If asked:

â€œHow do you test SwiftUI ViewModels?â€

Say:

â€œI unit test ViewModels by asserting state transitions using mock services. Views stay untested, logic stays deterministic, and async behavior is covered.â€

â­ Golden Rules

Test states, not views

Mock all dependencies

Cover success & failure

Prefer enums over booleans

Keep ViewModels pure

âœ… Day 2 Complete

You now have:

Production-grade ViewModel testing

Async-safe tests

Deterministic mocks

Interview-ready answers
