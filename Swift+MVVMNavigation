ğŸ§­ SwiftUI MVVM + Navigation Coordinator

In production SwiftUI apps, navigation should be data-driven, not embedded inside views.
A Navigation Coordinator separates navigation logic from UI rendering.

This pattern scales well for:

Complex flows

Deep links

Multi-step journeys

Feature modularization

ğŸ§  Core Idea
View â†’ ViewModel â†’ Coordinator â†’ NavigationStack


Views do not navigate

ViewModels request navigation

Coordinator owns navigation state

ğŸ“ Recommended Structure
App/
 â”œâ”€ AppCoordinator.swift
 â”œâ”€ AppRoute.swift
Features/
 â”œâ”€ Home/
 â”‚   â”œâ”€ HomeView.swift
 â”‚   â””â”€ HomeViewModel.swift
 â”œâ”€ Profile/
 â”‚   â”œâ”€ ProfileView.swift
 â”‚   â””â”€ ProfileViewModel.swift

1ï¸âƒ£ Define Routes (Navigation = Data)
enum AppRoute: Hashable {
    case profile(userId: String)
    case settings
}


âœ… Hashable
âœ… Serializable
âœ… Deep-link friendly

2ï¸âƒ£ Navigation Coordinator (Single Source of Truth)
import SwiftUI

@MainActor
final class AppCoordinator: ObservableObject {

    @Published var path: [AppRoute] = []

    func navigate(to route: AppRoute) {
        path.append(route)
    }

    func pop() {
        path.removeLast()
    }

    func popToRoot() {
        path.removeAll()
    }
}

Responsibilities

Owns navigation state

Handles push/pop/reset

No UI code

3ï¸âƒ£ Root NavigationStack (App Entry)
struct RootView: View {

    @StateObject private var coordinator = AppCoordinator()

    var body: some View {
        NavigationStack(path: $coordinator.path) {
            HomeView(viewModel: HomeViewModel(coordinator: coordinator))
                .navigationDestination(for: AppRoute.self) { route in
                    switch route {
                    case .profile(let userId):
                        ProfileView(
                            viewModel: ProfileViewModel(
                                userId: userId,
                                coordinator: coordinator
                            )
                        )

                    case .settings:
                        SettingsView()
                    }
                }
        }
    }
}


âœ… Centralized navigation
âœ… Predictable
âœ… Easy to debug

4ï¸âƒ£ ViewModel Requests Navigation (Not the View)
final class HomeViewModel: ObservableObject {

    private let coordinator: AppCoordinator

    init(coordinator: AppCoordinator) {
        self.coordinator = coordinator
    }

    func onProfileTap() {
        coordinator.navigate(to: .profile(userId: "123"))
    }
}


ğŸ’¡ ViewModel does not know about NavigationStack

5ï¸âƒ£ View Is a Pure Renderer
struct HomeView: View {

    @StateObject private var viewModel: HomeViewModel

    init(viewModel: HomeViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
    }

    var body: some View {
        VStack(spacing: 20) {

            Text("Home")
                .font(.title2)

            Button("Go to Profile") {
                viewModel.onProfileTap()
            }

        }
        .padding()
    }
}


âœ… No navigation code
âœ… No routes
âœ… No side effects

6ï¸âƒ£ Destination ViewModel (Receives Dependencies)
final class ProfileViewModel: ObservableObject {

    let userId: String
    private let coordinator: AppCoordinator

    init(userId: String, coordinator: AppCoordinator) {
        self.userId = userId
        self.coordinator = coordinator
    }

    func close() {
        coordinator.pop()
    }
}

7ï¸âƒ£ Why This Pattern Works
Problem	Solved
Navigation logic scattered	Centralized
Hard-to-test navigation	Testable
Deep linking	Natural
Multi-step flows	Easy
State resets confusion	Explicit
ğŸš« What This Avoids

âŒ Navigation inside Views

âŒ String-based navigation

âŒ Massive ViewModels

âŒ UIKit-style coordinators

âŒ Hidden side effects

ğŸ§  Interview Power Answer

If asked:

â€œHow do you handle navigation in SwiftUI MVVM?â€

Say:

â€œI use a navigation coordinator with a data-driven NavigationStack. ViewModels request navigation via routes, and the coordinator owns the navigation state.â€

â­ When to Use This Pattern

Use MVVM + Coordinator when:

App has more than 3â€“4 screens

Navigation logic is non-trivial

You need deep linking

Multiple teams work on features

Skip it for:

Very small apps

Single-screen tools

ğŸ”¥ Golden Rules

Navigation is data

Views donâ€™t navigate

ViewModels donâ€™t know UI

Coordinator owns flow

One stack, many features
