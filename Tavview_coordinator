ğŸ“‘ SwiftUI TabView + Coordinator Architecture

In real apps, TabView introduces multiple navigation stacks.
A proper coordinator setup avoids:

State leakage across tabs

Broken back stacks

Navigation chaos

This pattern keeps each tab isolated and predictable.

ğŸ§  Core Idea
TabCoordinator
 â”œâ”€ HomeCoordinator â†’ NavigationStack
 â”œâ”€ SearchCoordinator â†’ NavigationStack
 â””â”€ ProfileCoordinator â†’ NavigationStack


âœ… Each tab owns its own navigation stack
âœ… Navigation state survives tab switching
âœ… Deep linking becomes manageable

ğŸ“ Recommended Structure
App/
 â”œâ”€ TabCoordinator.swift
 â”œâ”€ TabRoute.swift
 â””â”€ RootTabView.swift
Features/
 â”œâ”€ Home/
 â”œâ”€ Search/
 â””â”€ Profile/

1ï¸âƒ£ Define Tabs
enum AppTab: Hashable {
    case home
    case search
    case profile
}

2ï¸âƒ£ Define Routes Per Tab
enum HomeRoute: Hashable {
    case details(id: String)
}

enum SearchRoute: Hashable {
    case result(query: String)
}

enum ProfileRoute: Hashable {
    case settings
}

3ï¸âƒ£ Tab Coordinator (Top-Level Owner)
import SwiftUI

@MainActor
final class TabCoordinator: ObservableObject {

    @Published var selectedTab: AppTab = .home

    // Separate navigation paths per tab
    @Published var homePath: [HomeRoute] = []
    @Published var searchPath: [SearchRoute] = []
    @Published var profilePath: [ProfileRoute] = []

    func switchTab(_ tab: AppTab) {
        selectedTab = tab
    }
}


âœ… One coordinator
âœ… Multiple navigation states
âœ… Explicit control

4ï¸âƒ£ Root TabView
struct RootTabView: View {

    @StateObject private var coordinator = TabCoordinator()

    var body: some View {
        TabView(selection: $coordinator.selectedTab) {

            HomeStack(coordinator: coordinator)
                .tabItem {
                    Label("Home", systemImage: "house")
                }
                .tag(AppTab.home)

            SearchStack(coordinator: coordinator)
                .tabItem {
                    Label("Search", systemImage: "magnifyingglass")
                }
                .tag(AppTab.search)

            ProfileStack(coordinator: coordinator)
                .tabItem {
                    Label("Profile", systemImage: "person")
                }
                .tag(AppTab.profile)
        }
    }
}

5ï¸âƒ£ Home Navigation Stack
struct HomeStack: View {

    @ObservedObject var coordinator: TabCoordinator

    var body: some View {
        NavigationStack(path: $coordinator.homePath) {
            HomeView(
                viewModel: HomeViewModel(coordinator: coordinator)
            )
            .navigationDestination(for: HomeRoute.self) { route in
                switch route {
                case .details(let id):
                    HomeDetailView(id: id)
                }
            }
        }
    }
}

6ï¸âƒ£ ViewModel Requests Navigation
final class HomeViewModel: ObservableObject {

    private let coordinator: TabCoordinator

    init(coordinator: TabCoordinator) {
        self.coordinator = coordinator
    }

    func showDetails() {
        coordinator.homePath.append(.details(id: "42"))
    }

    func goToProfileTab() {
        coordinator.switchTab(.profile)
    }
}


ğŸš« No NavigationLink
ğŸš« No tab logic in the view

7ï¸âƒ£ Why This Pattern Works
Problem	Solution
Tab resets navigation	Separate paths
Cross-tab navigation	Coordinator
State loss on tab switch	Persistent stacks
Complex flows	Centralized logic
ğŸš« Common Anti-Patterns

âŒ Single NavigationStack for all tabs
âŒ NavigationLinks inside TabView
âŒ Switching tabs from views
âŒ Shared state across tabs

ğŸ§  Interview Power Answer

If asked:

â€œHow do you handle navigation with TabView in SwiftUI?â€

Say:

â€œEach tab owns its own NavigationStack, coordinated by a TabCoordinator. Navigation is data-driven and isolated per tab, which prevents state loss and scales well.â€

â­ When to Use TabView + Coordinator

Use this pattern when:

App has 2+ tabs

Each tab has deep navigation

State must persist per tab

You need cross-tab navigation

Skip it for:

Simple, single-stack apps

One-tab utilities

ğŸ”¥ Golden Rules

One tab = one navigation stack

Navigation is state

Tabs never navigate themselves

Coordinators own flow

Views only render
