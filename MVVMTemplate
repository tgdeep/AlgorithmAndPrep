ğŸ§© Production-Grade SwiftUI MVVM Template

This template shows how MVVM should look in a real SwiftUI app, not a demo project.

It focuses on:

Clear separation of concerns

Testability

Async support

Dependency injection

Predictable state flow

ğŸ“ Recommended Folder Structure
Features/
 â””â”€ Profile/
     â”œâ”€ ProfileView.swift
     â”œâ”€ ProfileViewModel.swift
     â”œâ”€ ProfileState.swift
     â”œâ”€ ProfileService.swift
     â””â”€ ProfileModels.swift
Core/
 â”œâ”€ Networking/
 â”œâ”€ Services/
 â””â”€ Utilities/


ğŸ‘‰ Feature-based, not layer-based.

1ï¸âƒ£ View (Pure Rendering Layer)
import SwiftUI

struct ProfileView: View {

    @StateObject private var viewModel: ProfileViewModel

    init(viewModel: ProfileViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)
    }

    var body: some View {
        content
            .navigationTitle("Profile")
            .task {
                await viewModel.loadProfile()
            }
    }

    @ViewBuilder
    private var content: some View {
        switch viewModel.state {
        case .idle, .loading:
            ProgressView()

        case .loaded(let profile):
            VStack(spacing: 16) {
                Text(profile.name)
                    .font(.title2)

                Text(profile.email)
                    .foregroundColor(.secondary)

                Button("Refresh") {
                    Task {
                        await viewModel.loadProfile()
                    }
                }
            }

        case .error(let message):
            Text(message)
                .foregroundColor(.red)
        }
    }
}

âœ… View Responsibilities

Renders UI

Triggers actions

Observes state

No business logic

2ï¸âƒ£ View State (Single Source of Truth)
enum ProfileState {
    case idle
    case loading
    case loaded(Profile)
    case error(String)
}

Why this matters

Explicit UI states

No boolean explosion

Easy debugging

Easy testing

3ï¸âƒ£ ViewModel (Logic + State Owner)
import Foundation

@MainActor
final class ProfileViewModel: ObservableObject {

    @Published private(set) var state: ProfileState = .idle

    private let service: ProfileServicing

    init(service: ProfileServicing) {
        self.service = service
    }

    func loadProfile() async {
        state = .loading

        do {
            let profile = try await service.fetchProfile()
            state = .loaded(profile)
        } catch {
            state = .error("Failed to load profile")
        }
    }
}

âœ… ViewModel Responsibilities

Owns state

Runs business logic

Handles async work

No UI code

4ï¸âƒ£ Service Layer (Dependency Injection)
protocol ProfileServicing {
    func fetchProfile() async throws -> Profile
}

Concrete Implementation
struct ProfileService: ProfileServicing {
    func fetchProfile() async throws -> Profile {
        try await Task.sleep(nanoseconds: 1_000_000_000)
        return Profile(name: "Deepak", email: "deepak@example.com")
    }
}

5ï¸âƒ£ Model (Plain Data)
struct Profile {
    let name: String
    let email: String
}

6ï¸âƒ£ Dependency Injection (Production Setup)
@main
struct MyApp: App {

    var body: some Scene {
        WindowGroup {
            NavigationStack {
                ProfileView(
                    viewModel: ProfileViewModel(
                        service: ProfileService()
                    )
                )
            }
        }
    }
}


ğŸ‘‰ No singletons
ğŸ‘‰ No hidden dependencies
ğŸ‘‰ Easy to swap mocks

7ï¸âƒ£ Unit Testing the ViewModel
final class MockProfileService: ProfileServicing {
    func fetchProfile() async throws -> Profile {
        Profile(name: "Test", email: "test@test.com")
    }
}

func testProfileLoadedState() async {
    let vm = ProfileViewModel(service: MockProfileService())

    await vm.loadProfile()

    if case .loaded(let profile) = vm.state {
        XCTAssertEqual(profile.name, "Test")
    } else {
        XCTFail("Expected loaded state")
    }
}

ğŸ§  Why This MVVM Is Production-Grade

âœ… Explicit UI state
âœ… Async-safe (@MainActor)
âœ… Dependency-injected
âœ… Easy to test
âœ… Scales per feature
âœ… No logic in views
âœ… No massive ViewModels

ğŸš« What This Template Avoids

âŒ Logic inside View

âŒ @ObservedObject ownership

âŒ Boolean flags like isLoading

âŒ Singleton services

âŒ Implicit dependencies

âŒ UIKit-style controllers

â­ Interview Power Answer

If asked:

â€œHow do you structure SwiftUI MVVM?â€

Say:

â€œI use feature-based MVVM with explicit UI states, async ViewModels, protocol-based services, and dependency injection. Views are pure renderers.â€

ğŸ”¥ MVVM Golden Rules

Views render, ViewModels decide

State is explicit

Async work lives in ViewModel

Services are injected

One feature = one ViewModel

No side effects in body
