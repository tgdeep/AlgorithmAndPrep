ğŸ§ª SwiftUI Coordinator Unit Tests

Navigation in SwiftUI is state-driven, which makes coordinators highly testable.
You donâ€™t test views â€” you test navigation state changes.

ğŸ§  What to Test in a Coordinator

âœ… Path mutations
âœ… Tab switching
âœ… Pop / reset behavior
âœ… Deep-link handling
âŒ UI rendering
âŒ NavigationStack itself

Coordinators are pure logic â€” perfect for unit tests.

1ï¸âƒ£ Example Coordinator (Under Test)
@MainActor
final class AppCoordinator: ObservableObject {

    @Published var path: [AppRoute] = []

    func navigate(to route: AppRoute) {
        path.append(route)
    }

    func pop() {
        guard !path.isEmpty else { return }
        path.removeLast()
    }

    func popToRoot() {
        path.removeAll()
    }
}

2ï¸âƒ£ Test Setup
import XCTest
@testable import YourAppModule

@MainActor
final class AppCoordinatorTests: XCTestCase {

    var coordinator: AppCoordinator!

    override func setUp() {
        super.setUp()
        coordinator = AppCoordinator()
    }

    override func tearDown() {
        coordinator = nil
        super.tearDown()
    }
}

3ï¸âƒ£ Test Navigation Push
func testNavigatePushesRoute() {
    coordinator.navigate(to: .profile(userId: "123"))

    XCTAssertEqual(coordinator.path.count, 1)
    XCTAssertEqual(coordinator.path.first, .profile(userId: "123"))
}


âœ… Verifies navigation intent
âœ… No UI involved

4ï¸âƒ£ Test Pop Behavior
func testPopRemovesLastRoute() {
    coordinator.navigate(to: .profile(userId: "1"))
    coordinator.navigate(to: .settings)

    coordinator.pop()

    XCTAssertEqual(coordinator.path.count, 1)
    XCTAssertEqual(coordinator.path.first, .profile(userId: "1"))
}

5ï¸âƒ£ Test Pop to Root
func testPopToRootClearsPath() {
    coordinator.navigate(to: .profile(userId: "1"))
    coordinator.navigate(to: .settings)

    coordinator.popToRoot()

    XCTAssertTrue(coordinator.path.isEmpty)
}

6ï¸âƒ£ Testing Tab Coordinator
Coordinator
@MainActor
final class TabCoordinator: ObservableObject {

    @Published var selectedTab: AppTab = .home
    @Published var homePath: [HomeRoute] = []

    func switchTab(_ tab: AppTab) {
        selectedTab = tab
    }
}

Test Tab Switching
func testTabSwitching() {
    let coordinator = TabCoordinator()

    coordinator.switchTab(.profile)

    XCTAssertEqual(coordinator.selectedTab, .profile)
}

7ï¸âƒ£ Test Cross-Tab Navigation
func testHomeNavigationPath() {
    let coordinator = TabCoordinator()

    coordinator.homePath.append(.details(id: "42"))

    XCTAssertEqual(coordinator.homePath.count, 1)
    XCTAssertEqual(coordinator.homePath.first, .details(id: "42"))
}

8ï¸âƒ£ Deep Link Test (Advanced)
func testDeepLinkNavigation() {
    coordinator.navigate(to: .profile(userId: "999"))

    XCTAssertEqual(
        coordinator.path,
        [.profile(userId: "999")]
    )
}


ğŸ’¡ Deep links become simple state assertions.

9ï¸âƒ£ What NOT to Test

ğŸš« NavigationStack behavior
ğŸš« View rendering
ğŸš« SwiftUI animations
ğŸš« System navigation transitions

Apple already tested those.

ğŸ”¥ Why Coordinator Tests Are Powerful
Benefit	Reason
Fast tests	No UI involved
Deterministic	Pure state
Easy debugging	Clear failures
CI-friendly	No simulators
ğŸ§  Interview Power Answer

If asked:

â€œHow do you test navigation in SwiftUI?â€

Say:

â€œI test the coordinator directly by asserting navigation state changes. Since navigation is data-driven, coordinators are pure logic and easy to unit test.â€

â­ Best Practices

Keep coordinators UI-free

Make routes Hashable

Test path mutations

Avoid NavigationLink in tests

One coordinator = one responsibility

ğŸ”š Key Takeaway

If navigation is state,
navigation tests are just state tests.
