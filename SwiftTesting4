üìÖ SwiftUI Testing Series

Snapshot Testing ‚úÖ

ViewModel Testing ‚úÖ

Async & Concurrency Testing ‚úÖ

Navigation & Coordinator Testing (Advanced) ‚¨ÖÔ∏è Today

CI Testing Strategy

üß≠ SwiftUI Navigation & Coordinator Testing (Day 4)

If your navigation isn‚Äôt testable, your architecture isn‚Äôt scalable.

SwiftUI‚Äôs NavigationStack is state-driven, which makes navigation logic surprisingly easy to unit test ‚Äî if you structured it correctly.

Navigation is just state mutation.
If it‚Äôs not, you architected it wrong.

üß† What You Should Test

‚úÖ Route pushing
‚úÖ Route popping
‚úÖ Reset to root
‚úÖ Cross-tab navigation
‚úÖ Deep link handling
‚ùå NavigationStack rendering
‚ùå SwiftUI transitions

1Ô∏è‚É£ Example Coordinator
@MainActor
final class AppCoordinator: ObservableObject {

    @Published var path: [AppRoute] = []

    func navigate(to route: AppRoute) {
        path.append(route)
    }

    func pop() {
        guard !path.isEmpty else { return }
        path.removeLast()
    }

    func popToRoot() {
        path.removeAll()
    }
}

2Ô∏è‚É£ Basic Push Test
func testNavigatePushesRoute() {
    let coordinator = AppCoordinator()

    coordinator.navigate(to: .profile(userId: "123"))

    XCTAssertEqual(coordinator.path.count, 1)
    XCTAssertEqual(coordinator.path.first, .profile(userId: "123"))
}


You are not testing UI.
You are testing navigation intent.

3Ô∏è‚É£ Pop Behavior Test
func testPopRemovesLastRoute() {
    let coordinator = AppCoordinator()

    coordinator.navigate(to: .profile(userId: "1"))
    coordinator.navigate(to: .settings)

    coordinator.pop()

    XCTAssertEqual(coordinator.path, [.profile(userId: "1")])
}


Edge case mindset. Good engineers think about removal behavior.

4Ô∏è‚É£ Pop To Root Test
func testPopToRootClearsPath() {
    let coordinator = AppCoordinator()

    coordinator.navigate(to: .profile(userId: "1"))
    coordinator.navigate(to: .settings)

    coordinator.popToRoot()

    XCTAssertTrue(coordinator.path.isEmpty)
}

5Ô∏è‚É£ Testing ViewModel ‚Üí Coordinator Interaction

Your ViewModel should not know about NavigationStack.
It should only request navigation.

ViewModel
final class HomeViewModel {

    private let coordinator: AppCoordinator

    init(coordinator: AppCoordinator) {
        self.coordinator = coordinator
    }

    func onProfileTap() {
        coordinator.navigate(to: .profile(userId: "42"))
    }
}

Test
func testProfileTapNavigates() {
    let coordinator = AppCoordinator()
    let vm = HomeViewModel(coordinator: coordinator)

    vm.onProfileTap()

    XCTAssertEqual(coordinator.path.first, .profile(userId: "42"))
}


Clean. Deterministic. Zero UI dependency.

6Ô∏è‚É£ Testing Cross-Tab Navigation

If using TabCoordinator:

@MainActor
final class TabCoordinator: ObservableObject {

    @Published var selectedTab: AppTab = .home
    @Published var homePath: [HomeRoute] = []

    func switchTab(_ tab: AppTab) {
        selectedTab = tab
    }
}

Test
func testSwitchTab() {
    let coordinator = TabCoordinator()

    coordinator.switchTab(.profile)

    XCTAssertEqual(coordinator.selectedTab, .profile)
}


Navigation is just state.
Stop overcomplicating it.

7Ô∏è‚É£ Testing Deep Linking

If you support deep links:

func handleDeepLink(_ route: AppRoute) {
    path = [route]
}

Test
func testDeepLinkSetsPath() {
    let coordinator = AppCoordinator()

    coordinator.handleDeepLink(.profile(userId: "999"))

    XCTAssertEqual(coordinator.path, [.profile(userId: "999")])
}


Deep linking becomes trivial when navigation is data.

8Ô∏è‚É£ Advanced: Preventing Duplicate Pushes

If you guard against duplicate navigation:

func navigateIfNeeded(to route: AppRoute) {
    guard path.last != route else { return }
    path.append(route)
}

Test
func testDuplicateNavigationPrevented() {
    let coordinator = AppCoordinator()

    coordinator.navigateIfNeeded(to: .settings)
    coordinator.navigateIfNeeded(to: .settings)

    XCTAssertEqual(coordinator.path.count, 1)
}


Now you‚Äôre thinking like someone who‚Äôs shipped apps.

üî• Common Navigation Testing Mistakes

‚ùå Testing NavigationStack directly
‚ùå Using UI tests for simple push logic
‚ùå Embedding navigation inside Views
‚ùå Using string-based routes
‚ùå Not making routes Hashable

üß† Interview Power Answer

If asked:

‚ÄúHow do you test navigation in SwiftUI?‚Äù

Say:

‚ÄúI treat navigation as state. Coordinators own route arrays, and I assert path mutations directly in unit tests.‚Äù

That sentence alone separates you from 70% of candidates.

‚≠ê Golden Rules

Navigation is data

Coordinators own path

ViewModels request navigation

Never test SwiftUI rendering

Keep coordinators UI-free

‚úÖ Day 4 Complete

You now know how to test:

Push

Pop

Reset

Cross-tab navigation

Deep links

Duplicate prevention

üìå Final Topic Tomorrow

When you say ‚Äúgive me next topic‚Äù, we‚Äôll finish strong with:

üëâ Day 5 ‚Äì SwiftUI CI Testing Strategy (GitHub Actions / Xcode Cloud / Fastlane)

We‚Äôre building a serious, production-ready testing guide here.
One more day and it‚Äôs a complete series.

I prefer this response
